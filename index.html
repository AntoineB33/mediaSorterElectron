<!DOCTYPE html>
<html>
<head>
    <title>Video Player App</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        video {
            width: 100%;
            height: 100%;
        }
        #video {
            display: block;
        }
        #image {
            display: none;
        }
    </style>
</head>
<body>
    <video id="video" autoplay>
        <!-- <source src="../../videos/view.mp4" type="video/mp4"> -->
        <source id="placeholder" src="" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <img id="image" src="">
    <script>
        const VOL_SPEED = 3;
        const MEDIA_DATA_PATH = "mediaData";
        const DEF_BG_NAME = "b";
        const DEF_BG_REAL_NAME = "black_default_background.jpg";
        const extensionList = [".jpg",".png",".gif",".mp4"];
        const extensionsToCheck = [
        { directory: "videos\\", extension: ".mp4" },
        { directory: "images\\", extension: ".jpg" },
        { directory: "images\\", extension: ".png" },
        { directory: "images\\", extension: ".gif" }
        ];

        const mediaDataPath = MEDIA_DATA_PATH + "/";
        const { remote } = require('electron');
        const fs = require('fs');
        const placeholder = document.getElementById('placeholder');
        const image = document.getElementById('image');

        let backgrounds = [[0,DEF_BG_REAL_NAME]];
        let mediaList = [];
        let currentMediaInd = -1;
        let videoPlaying = false;


        // Function to load and play the next video
        function loadNextVideo(step) {
            const currentMediaIndI = Math.max(0,Math.min(currentMediaInd + step,mediaList.length-1));
            if (currentMediaInd != currentMediaIndI) {
                currentMediaInd = currentMediaIndI;
                if(mediaList[currentMediaInd].slice(-4)==".mp4") {
                    placeholder.src = "../../videos/" + mediaList[currentMediaInd];
                    video.load();
                    video.play();
                    if(!videoPlaying) {
                        placeholder.style.display = 'block';
                        image.style.display = 'none';
                    }
                } else {
                    video.pause();
                    image.src = "../../images/" + mediaList[currentMediaInd];
                    if(videoPlaying) {
                        image.style.display = 'block';
                        placeholder.style.display = 'none';
                    }
                }
            }
        }
        // Read the list of video file paths from the text file
        fs.readFile('mediaData/tr.txt', 'utf8', (err, data) => {
            if (err) {
                console.error('Error reading video_list.txt:', err);
                return;
            }
            // Split the file content by newline to get individual lines
            let lines = data.split('\n');

            let line = lines[0].split('\t');
            let urlInd = -1; // Initialize the index variable to -1
            for (let i = 4; i < line.length; i++) {
                if (line[i] === 'url') {
                    urlInd = i;
                    break; // Exit the loop when 'url' is found
                }
            }

            // Extract video paths after the 6th tab character in each line
            lines = lines.slice(1);
            for(const line in lines.slice(1)) {
                const tabSeparatedValues = line.split('\t');
                if (tabSeparatedValues.length > urlInd) {
                    const url = tabSeparatedValues[urlInd].trim();
                    if (url) {
                        if (url.startsWith('https://') && (url.charAt(8) === 'e' || url.charAt(8) === 'w')) {
                            if (url.charAt(8) === 'e') {
                                const videoName = url.split('videos/').pop().split('?')[0] + '.mp4';
                                url = 'https_e_' + videoName;
                            } else if (url.charAt(8) === 'w') {
                                const videoID = url.split('&')[0].split('?v=').pop() + '.mp4';
                                url = 'https_y_' + videoID;
                            }
                        }
                        if(!extensionList.include(url.slice(-4))) {

                            let found = false;

                            for (const { directory, extension } of extensionsToCheck) {
                                const filePath = `../../${directory}${url}${extension}`;

                                if (fs.existsSync(filePath)) {
                                    url += extension;
                                    found = true;
                                    break;
                                }
                            }

                            if (!found) {
                                throw new Error("Wrong extension: " + name);
                            }
                        }
                        if (splitStr[4] === "-") {
                            if (url === DEF_BG_NAME) {
                                url = DEF_BG_REAL_NAME;
                            }
                            
                            if (backgrounds.length > 0 && backgrounds[backgrounds.length - 1][0] === mediaList.length) {
                                backgrounds[backgrounds.length - 1][1] = url;
                            } else {
                                backgrounds.push([mediaList.length, url]);
                            }
                        } else {
                            mediaList.push(url);
                        }
                    }
                }
            }
            loadNextVideo(1);
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowRight') {
                loadNextVideo(1);
            } else if (event.key === 'ArrowLeft') {
                loadNextVideo(-1);
            }
        });
    </script>
</body>
</html>
